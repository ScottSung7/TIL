### Kafka

- Retry 전략	- DLT 
  - 일괄적으로 적용하기 보다 Retrable한지 아닌지의 여부를 알고 적용하기. 재시도 불가능시 빠르게 DLT하는것도 좋다.
	-> retry하게 구현하려고 하면, 오히려 부하만 많아 질 수 있다.
  - Exponential, Random, Fixed. 
[Kafka Retry 정책](https://velog.io/@ce19f003/Kafka-Retry-%EC%A0%95%EC%B1%85-feat.-backoff-DLTDLQ)
[Consumer 코드](https://velog.io/@youmakemesmile/Spring-KafkaKafka-Consumer-%EC%A0%95%EB%A6%AC)
[get vs. join](https://luna-archive.tistory.com/32)

- Completable Future
	-  Blocking : get(checked ex.) / join(unchecked) 
	- Async 전략. <br>
[Completable Future in general](https://wbluke.tistory.com/50)

- MSA와 관련 있는 부분
  - 트랜잭션
    - 2PC 방지. (SAGA를 이용한 실패 이벤트 발행)
    [2PC](https://kadensungbincho.tistory.com/125)
    - Kafka. [Kafka-Transaction](https://incheol-jung.gitbook.io/docs/q-and-a/spring/transaction)
      - 1. @TransactionalEventListener
      - 2. @Transactional
      -> props.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, READ_COMMITTED);
      - 3. transaction-id-prefix (KafkaTransactionMager) isolation
      -> read committed로 변경
  - 서비스 매쉬
    - MS의 독립성 보장. -> 카프카를 통한 느슨한 결합
  - 장애처리
    - 서킷브레이킹, 타임아웃 (Retry 전략) <br>
[MSA 설계시 고려할 점](https://wso2.com/ko/whitepapers/microservices-in-practice-key-architectural-concepts-of-an-msa/#103)
